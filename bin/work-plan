#!/usr/bin/env cosmic

local spawn = require("cosmic.child")
local fs = require("cosmic.fs")
local json = require("cosmic.json")
local env = require("cosmic.env")
local proc = require("cosmic.proc")
local getopt = require("cosmic.getopt")

local M = {}

local function usage()
  io.stderr:write("usage: work-plan --repo <owner/repo> [--issue <number>]\n")
end

local function read_file(path)
  local f = io.open(path, "r")
  if not f then return nil end
  local content = f:read("*a")
  f:close()
  return content
end

local function file_exists(path)
  local f = io.open(path, "r")
  if f then f:close() return true end
  return false
end

local function run(cmd)
  local handle, err = spawn.spawn(cmd, {env = env.all()})
  if not handle then return false, nil, err end
  local ok, stdout, exit_str = handle:read()
  local exit_code = tonumber(exit_str) or 0
  return ok and exit_code == 0, stdout, exit_code
end

function M.get_priority(labels)
  for _, label in ipairs(labels) do
    if label.name == "p0" then return 0 end
    if label.name == "p1" then return 1 end
    if label.name == "p2" then return 2 end
  end
  return 3
end

function M.sort_issues(issues)
  table.sort(issues, function(a, b)
    local a_priority = M.get_priority(a.labels)
    local b_priority = M.get_priority(b.labels)
    if a_priority ~= b_priority then
      return a_priority < b_priority
    end
    return a.createdAt < b.createdAt
  end)
end

function M.fetch_issues(repo)
  local ok, stdout = run({
    "gh", "issue", "list",
    "--repo", repo,
    "--label", "todo",
    "--state", "open",
    "--json", "number,title,body,url,labels,createdAt",
    "--limit", "100"
  })
  if not ok then return nil, "gh command failed" end
  local success, issues = pcall(json.decode, stdout)
  if not success or type(issues) ~= "table" then
    return nil, "failed to parse JSON"
  end
  return issues
end

function M.select_issue(issues)
  if #issues == 0 then return nil end
  M.sort_issues(issues)
  local s = issues[1]
  return {number = s.number, title = s.title, body = s.body, url = s.url}
end

function M.fetch_issue(repo, issue_number)
  local ok, stdout = run({
    "gh", "issue", "view", tostring(issue_number),
    "--repo", repo,
    "--json", "number,title,body,url"
  })
  if not ok then return nil, "gh command failed" end
  local success, issue = pcall(json.decode, stdout)
  if not success or type(issue) ~= "table" then
    return nil, "failed to parse JSON"
  end
  return issue
end

function M.transition_to_doing(issue_url)
  run({"gh", "issue", "edit", issue_url, "--remove-label", "todo", "--add-label", "doing"})
end

function M.main(args)
  local repo, issue_number

  local longopts = {
    {name = "help", has_arg = "none", short = "h"},
    {name = "repo", has_arg = "required", short = "r"},
    {name = "issue", has_arg = "required", short = "i"},
  }

  local parser = getopt.new(args, "hr:i:", longopts)

  while true do
    local opt, optarg = parser:next()
    if not opt then break end
    if opt == "h" or opt == "help" then
      usage()
      return 0
    elseif opt == "r" or opt == "repo" then
      repo = optarg
    elseif opt == "i" or opt == "issue" then
      issue_number = tonumber(optarg)
    elseif opt == "?" then
      usage()
      return 1
    end
  end

  if not repo then
    usage()
    return 1
  end

  -- Select or fetch issue
  local issue, err
  if issue_number then
    issue, err = M.fetch_issue(repo, issue_number)
  else
    local issues
    issues, err = M.fetch_issues(repo)
    if issues then
      issue = M.select_issue(issues)
    end
  end

  if err then
    io.stderr:write("error: " .. err .. "\n")
    return 1
  end

  if not issue then
    -- No issue to work on, exit cleanly
    return 0
  end

  -- Output issue for workflow
  print("issue=" .. json.encode(issue))

  -- Transition to doing
  M.transition_to_doing(issue.url)

  -- Run plan phase
  fs.makedirs("o/work/plan")

  -- Save issue data for downstream phases
  local issue_f = io.open("o/work/plan/issue.json", "w")
  if issue_f then
    issue_f:write(json.encode(issue) .. "\n")
    issue_f:close()
  end

  local prompt = read_file("sys/work/plan.md")
  if not prompt then
    io.stderr:write("error: could not read sys/work/plan.md\n")
    return 1
  end

  prompt = prompt:gsub("{title}", issue.title)
  prompt = prompt:gsub("{body}", issue.body or "")
  prompt = prompt:gsub("{issue_number}", tostring(issue.number))

  local ok = run({"o/bin/ah", "-n", "--db", "o/work/plan/session.db", prompt})

  if not ok then
    io.stderr:write("error: ah failed\n")
    return 1
  end

  if not file_exists("o/work/plan/plan.md") then
    io.stderr:write("error: plan.md not created\n")
    return 1
  end

  return 0
end

if proc.is_main() then
  os.exit(M.main(arg) or 0)
end

return M
