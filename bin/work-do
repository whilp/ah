#!/usr/bin/env cosmic

local spawn = require("cosmic.child")
local fs = require("cosmic.fs")
local env = require("cosmic.env")
local proc = require("cosmic.proc")
local getopt = require("cosmic.getopt")

local M = {}

function M.extract_branch(plan_contents, default_number)
  return plan_contents:match("Branch: ([^\n]+)") or ("work/" .. default_number)
end

local function usage()
  io.stderr:write("usage: work-do --title <title> --number <number>\n")
end

local function read_file(path)
  local f = io.open(path, "r")
  if not f then return nil end
  local content = f:read("*a")
  f:close()
  return content
end

local function write_file(path, content)
  local f = io.open(path, "w")
  if not f then return false end
  f:write(content)
  f:close()
  return true
end

function M.main(args)
  local title, number

  local longopts = {
    {name = "help", has_arg = "none", short = "h"},
    {name = "title", has_arg = "required", short = "t"},
    {name = "number", has_arg = "required", short = "n"},
  }

  local parser = getopt.new(args, "ht:n:", longopts)

  while true do
    local opt, optarg = parser:next()
    if not opt then break end

    if opt == "h" or opt == "help" then
      usage()
      return 0
    elseif opt == "t" or opt == "title" then
      title = optarg
    elseif opt == "n" or opt == "number" then
      number = optarg
    elseif opt == "?" then
      usage()
      return 1
    end
  end

  if not title or not number then
    usage()
    return 1
  end

  fs.makedirs("o/work/do")

  local plan_contents = read_file("o/work/plan/plan.md")
  if not plan_contents then
    io.stderr:write("error: could not read o/work/plan/plan.md\n")
    return 1
  end

  local prompt = read_file("sys/work/do.md")
  if not prompt then
    io.stderr:write("error: could not read sys/work/do.md\n")
    return 1
  end

  -- Extract branch from plan or use default
  local branch = M.extract_branch(plan_contents, number)

  prompt = prompt:gsub("{title}", title)
  prompt = prompt:gsub("{plan.md contents}", plan_contents)
  prompt = prompt:gsub("{branch}", branch)

  local handle, err = spawn.spawn({
    "o/bin/ah", "-n", "--db", "o/work/do/session.db", prompt
  }, {env = env.all()})

  if not handle then
    io.stderr:write("error: failed to spawn ah: " .. tostring(err) .. "\n")
    return 1
  end

  local ok, _, exit_str = handle:read()
  local exit_code = tonumber(exit_str) or 0

  if not ok or exit_code ~= 0 then
    io.stderr:write("error: ah exited with code " .. exit_code .. "\n")
    return 1
  end

  -- Save branch name for other phases
  write_file("o/work/do/branch.txt", branch .. "\n")

  return 0
end

if proc.is_main() then
  os.exit(M.main(arg) or 0)
end

return M
